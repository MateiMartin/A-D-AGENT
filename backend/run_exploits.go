package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"

	"ad_agent"
)

type ExploitResult struct {
	ServiceName string
	IP         string
	Output     string
	Error      error
}

// runExploitForIP runs a single exploit against a single IP
func runExploitForIP(scriptPath, serviceName, ip string, results chan<- ExploitResult) {
	cmd := exec.Command(ad_agent.PYTHON_COMMAND, scriptPath, ip)
	output, err := cmd.CombinedOutput()

	results <- ExploitResult{
		ServiceName: serviceName,
		IP:         ip,
		Output:     string(output),
		Error:      err,
	}
}

// runServiceExploit runs an exploit against all IPs associated with a service
func runServiceExploit(scriptPath string, service ad_agent.Service, wg *sync.WaitGroup, results chan<- ExploitResult) {
	defer wg.Done()

	// Create a WaitGroup for IP-level threading
	var ipWg sync.WaitGroup
	ipWg.Add(len(service.IPs))

	// Start a goroutine for each IP
	for _, ip := range service.IPs {
		go func(targetIP string) {
			defer ipWg.Done()
			runExploitForIP(scriptPath, service.Name, targetIP, results)
		}(ip)
	}

	// Wait for all IP exploits to complete
	ipWg.Wait()
}

// RunAllExploits executes all exploit files against their respective services
func RunAllExploits() ([]ExploitResult, error) {
	tmpDir := filepath.Join("tmp")
	files, err := ioutil.ReadDir(tmpDir)
	if err != nil {
		return nil, fmt.Errorf("failed to read tmp directory: %v", err)
	}

	serviceResults := make(chan []ExploitResult, len(ad_agent.SERVICES))
	var masterWg sync.WaitGroup

	// Start a goroutine for each service
	for _, service := range ad_agent.SERVICES {
		scriptPath := filepath.Join(tmpDir, fmt.Sprintf("exploit_%s.py", service.Name))
		if _, err := os.Stat(scriptPath); err != nil {
			continue // Skip if exploit doesn't exist
		}

		masterWg.Add(1)
		go func(svc ad_agent.Service, path string) {
			defer masterWg.Done()

			// Create a channel for this service's results
			results := make(chan ExploitResult, len(svc.IPs))
			var serviceWg sync.WaitGroup

			// Launch goroutines for each IP in this service
			for _, ip := range svc.IPs {
				serviceWg.Add(1)				go func(targetIP string) {
					defer serviceWg.Done()
					cmd := exec.Command(ad_agent.PYTHON_COMMAND, path, targetIP)
					output, err := cmd.CombinedOutput()

					results <- ExploitResult{
						ServiceName: svc.Name,
						IP:         targetIP,
						Output:     string(output),
						Error:      err,
					}
				}(ip)
			}

			// Wait for all IPs in this service to complete
			go func() {
				serviceWg.Wait()
				close(results)
			}()			// Process results for this service as they come in
			var serviceResultsList []ExploitResult
			for result := range results {
				cmdStr := fmt.Sprintf("%s %s %s", ad_agent.PYTHON_COMMAND, path, result.IP)
				fmt.Printf("\n[%s] Completed: %s\n", svc.Name, cmdStr)
				if result.Error != nil {
					fmt.Printf("Error: %v\n", result.Error)
				} else {
					fmt.Printf("Output:\n%s\n", result.Output)
				}
				fmt.Println("----------------------------------------")
				serviceResultsList = append(serviceResultsList, result)
			}
			serviceResults <- serviceResultsList
		}(service, scriptPath)
	}

	// Start a goroutine to close serviceResults when all services are done
	go func() {
		masterWg.Wait()
		close(serviceResults)
	}()
	// Collect all results
	var allResults []ExploitResult
	for results := range serviceResults {
		allResults = append(allResults, results...)
	}

	return allResults, nil
	}

	// Start a goroutine to close results channel when all work is done
	go func() {
		wg.Wait()
		close(results)
	}()

	// Collect all results
	var allResults []ExploitResult
	for result := range results {
		allResults = append(allResults, result)
	}

	return allResults, nil
}

// FilterExcludedIPs removes any results that target excluded IPs
func FilterExcludedIPs(results []ExploitResult) []ExploitResult {
	var filteredResults []ExploitResult

	for _, result := range results {
		excluded := false
		for _, excludedIP := range ad_agent.MYSERVICES_IPS {
			if strings.HasPrefix(result.IP, excludedIP) {
				excluded = true
				break
			}
		}
		if !excluded {
			filteredResults = append(filteredResults, result)
		}
	}

	return filteredResults
}
