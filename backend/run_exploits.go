package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"

	"ad_agent"
)

type ExploitResult struct {
	ServiceName string
	IP         string
	Output     string
	Error      error
}

// runExploitForIP runs a single exploit against a single IP
func runExploitForIP(scriptPath, serviceName, ip string, results chan<- ExploitResult) {
	cmd := exec.Command(ad_agent.PYTHON_COMMAND, scriptPath, ip)
	output, err := cmd.CombinedOutput()

	results <- ExploitResult{
		ServiceName: serviceName,
		IP:         ip,
		Output:     string(output),
		Error:      err,
	}
}

// runServiceExploit runs an exploit against all IPs associated with a service
func runServiceExploit(scriptPath string, service ad_agent.Service, wg *sync.WaitGroup, results chan<- ExploitResult) {
	defer wg.Done()

	// Create a WaitGroup for IP-level threading
	var ipWg sync.WaitGroup
	ipWg.Add(len(service.IPs))

	// Start a goroutine for each IP
	for _, ip := range service.IPs {
		go func(targetIP string) {
			defer ipWg.Done()
			runExploitForIP(scriptPath, service.Name, targetIP, results)
		}(ip)
	}

	// Wait for all IP exploits to complete
	ipWg.Wait()
}

// RunAllExploits executes all exploit files against their respective services
func RunAllExploits() ([]ExploitResult, error) {
	tmpDir := filepath.Join("tmp")
	files, err := ioutil.ReadDir(tmpDir)
	if err != nil {
		return nil, fmt.Errorf("failed to read tmp directory: %v", err)
	}

	var exploitFiles []string
	for _, file := range files {
		if strings.HasPrefix(file.Name(), "exploit_") && strings.HasSuffix(file.Name(), ".py") {
			exploitFiles = append(exploitFiles, file.Name())
		}
	}

	if len(exploitFiles) == 0 {
		return nil, fmt.Errorf("no exploit files found in tmp directory")
	}

	// Create a channel for results
	results := make(chan ExploitResult, len(ad_agent.SERVICES)*100) // Buffer size to prevent blocking
	var wg sync.WaitGroup

	// Start a goroutine for each service that has an exploit
	for _, file := range exploitFiles {
		// Extract service name from filename (remove "exploit_" prefix and ".py" suffix)
		serviceName := strings.TrimSuffix(strings.TrimPrefix(file, "exploit_"), ".py")

		// Find the corresponding service
		var service *ad_agent.Service
		for _, s := range ad_agent.SERVICES {
			if s.Name == serviceName {
				service = &s
				break
			}
		}

		if service == nil {
			fmt.Printf("Warning: No service configuration found for %s\n", serviceName)
			continue
		}

		wg.Add(1)
		go runServiceExploit(filepath.Join(tmpDir, file), *service, &wg, results)
	}

	// Start a goroutine to close results channel when all work is done
	go func() {
		wg.Wait()
		close(results)
	}()

	// Collect all results
	var allResults []ExploitResult
	for result := range results {
		allResults = append(allResults, result)
	}

	return allResults, nil
}

// FilterExcludedIPs removes any results that target excluded IPs
func FilterExcludedIPs(results []ExploitResult) []ExploitResult {
	var filteredResults []ExploitResult

	for _, result := range results {
		excluded := false
		for _, excludedIP := range ad_agent.MYSERVICES_IPS {
			if strings.HasPrefix(result.IP, excludedIP) {
				excluded = true
				break
			}
		}
		if !excluded {
			filteredResults = append(filteredResults, result)
		}
	}

	return filteredResults
}
